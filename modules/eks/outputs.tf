# modules/eks/outputs.tf

#==========================================
# EKS Cluster Core Outputs
#==========================================

output "cluster_id" {
  description = "The name/id of the EKS cluster"
  value       = aws_eks_cluster.main.id
}

output "cluster_name" {
  description = "The name of the EKS cluster"
  value       = aws_eks_cluster.main.name
}

output "cluster_arn" {
  description = "The Amazon Resource Name (ARN) of the cluster"
  value       = aws_eks_cluster.main.arn
}

output "cluster_endpoint" {
  description = "Endpoint for EKS control plane"
  value       = aws_eks_cluster.main.endpoint
}

output "cluster_version" {
  description = "The Kubernetes version for the EKS cluster"
  value       = aws_eks_cluster.main.version
}

output "cluster_platform_version" {
  description = "Platform version for the EKS cluster"
  value       = aws_eks_cluster.main.platform_version
}

output "cluster_status" {
  description = "Status of the EKS cluster. One of `CREATING`, `ACTIVE`, `DELETING`, `FAILED`"
  value       = aws_eks_cluster.main.status
}

#==========================================
# Cluster Certificate and Authentication
#==========================================

output "cluster_certificate_authority_data" {
  description = "Base64 encoded certificate data required to communicate with the cluster"
  value       = aws_eks_cluster.main.certificate_authority[0].data
}

output "cluster_ca_certificate" {
  description = "Decoded cluster CA certificate for kubectl configuration"
  value       = base64decode(aws_eks_cluster.main.certificate_authority[0].data)
  sensitive   = true
}

#==========================================
# OIDC Provider Outputs (for IRSA)
#==========================================

output "cluster_oidc_issuer_url" {
  description = "The URL on the EKS cluster OIDC Issuer"
  value       = aws_eks_cluster.main.identity[0].oidc[0].issuer
}

output "oidc_provider_arn" {
  description = "The ARN of the OIDC Provider for IRSA"
  value       = var.enable_irsa ? aws_iam_openid_connect_provider.cluster[0].arn : null
}

output "oidc_provider_url" {
  description = "URL of the OIDC Provider (without https://)"
  value       = var.enable_irsa ? replace(aws_eks_cluster.main.identity[0].oidc[0].issuer, "https://", "") : null
}

#==========================================
# Node Group Outputs
#==========================================

output "node_group_id" {
  description = "EKS node group ID"
  value       = aws_eks_node_group.main.id
}

output "node_group_arn" {
  description = "Amazon Resource Name (ARN) of the EKS Node Group"
  value       = aws_eks_node_group.main.arn
}

output "node_group_status" {
  description = "Status of the EKS Node Group"
  value       = aws_eks_node_group.main.status
}

output "node_group_capacity_type" {
  description = "Type of capacity associated with the EKS Node Group"
  value       = aws_eks_node_group.main.capacity_type
}

output "node_group_instance_types" {
  description = "Set of instance types associated with the EKS Node Group"
  value       = aws_eks_node_group.main.instance_types
}

output "node_group_ami_type" {
  description = "Type of Amazon Machine Image (AMI) associated with the EKS Node Group"
  value       = aws_eks_node_group.main.ami_type
}

output "node_group_disk_size" {
  description = "Disk size in GiB for worker nodes"
  value       = aws_eks_node_group.main.disk_size
}

#==========================================
# Security Group Outputs
#==========================================

output "cluster_security_group_id" {
  description = "Security group ID attached to the EKS cluster"
  value       = aws_eks_cluster.main.vpc_config[0].cluster_security_group_id
}

output "cluster_primary_security_group_id" {
  description = "The cluster primary security group ID created by EKS"
  value       = aws_eks_cluster.main.vpc_config[0].cluster_security_group_id
}

#==========================================
# Networking Outputs
#==========================================

output "cluster_vpc_id" {
  description = "ID of the VPC associated with the cluster"
  value       = var.vpc_id
}

output "cluster_subnet_ids" {
  description = "List of subnet IDs associated with the cluster"
  value       = var.subnet_ids
}

output "node_group_subnet_ids" {
  description = "List of subnet IDs where the nodes are deployed (private subnets)"
  value       = var.private_subnet_ids
}

#==========================================
# kubectl Configuration
#==========================================

output "kubectl_config" {
  description = "kubectl config as generated by the module"
  value = {
    cluster_name     = aws_eks_cluster.main.name
    endpoint         = aws_eks_cluster.main.endpoint
    ca_certificate   = aws_eks_cluster.main.certificate_authority[0].data
    region           = data.aws_region.current.name
    role_arn         = var.cluster_service_role_arn
  }
}

output "kubeconfig_certificate_authority_data" {
  description = "Certificate authority data for kubectl configuration"
  value       = aws_eks_cluster.main.certificate_authority[0].data
}

#==========================================
# CloudWatch Logging
#==========================================

output "cloudwatch_log_group_name" {
  description = "Name of cloudwatch log group for cluster logging"
  value       = aws_cloudwatch_log_group.cluster.name
}

output "cloudwatch_log_group_arn" {
  description = "ARN of cloudwatch log group for cluster logging"
  value       = aws_cloudwatch_log_group.cluster.arn
}

#==========================================
# EKS Add-ons Status
#==========================================

output "cluster_addons" {
  description = "Map of cluster add-on names to add-on properties"
  value = {
    vpc-cni = {
      addon_name    = aws_eks_addon.vpc_cni.addon_name
      addon_version = aws_eks_addon.vpc_cni.addon_version
      # Removed status - not available in AWS provider
    }
    coredns = {
      addon_name    = aws_eks_addon.coredns.addon_name
      addon_version = aws_eks_addon.coredns.addon_version
      # Removed status - not available in AWS provider
    }
    kube-proxy = {
      addon_name    = aws_eks_addon.kube_proxy.addon_name
      addon_version = aws_eks_addon.kube_proxy.addon_version
      # Removed status - not available in AWS provider
    }
    aws-ebs-csi-driver = var.enable_ebs_csi_driver ? {
      addon_name    = aws_eks_addon.ebs_csi_driver[0].addon_name
      addon_version = aws_eks_addon.ebs_csi_driver[0].addon_version
      # Removed status - not available in AWS provider
    } : null
  }
}


#==========================================
# Application Deployment Information
#==========================================

output "geodish_deployment_info" {
  description = "Information needed for GeoDish application deployment"
  value = {
    cluster_name           = aws_eks_cluster.main.name
    cluster_endpoint       = aws_eks_cluster.main.endpoint
    node_group_name        = aws_eks_node_group.main.node_group_name
    nodes_in_private_subnets = true
    ecr_repository         = "893692751288.dkr.ecr.ap-south-1.amazonaws.com/geodish-app"
    namespace_recommendation = "geodish-app"
  }
}

#==========================================
# Helm Integration Outputs
#==========================================

output "helm_repository_config" {
  description = "Helm repository configuration for AWS resources"
  value = {
    aws_load_balancer_controller = {
      repository = "https://aws.github.io/eks-charts"
      chart      = "aws-load-balancer-controller"
      namespace  = "kube-system"
    }
    aws_ebs_csi_driver = {
      repository = "https://kubernetes-sigs.github.io/aws-ebs-csi-driver"
      chart      = "aws-ebs-csi-driver"
      namespace  = "kube-system"
    }
  }
}

#==========================================
# Monitoring and Observability
#==========================================

output "monitoring_endpoints" {
  description = "Endpoints for monitoring the EKS cluster"
  value = {
    cloudwatch_logs    = aws_cloudwatch_log_group.cluster.name
    cluster_endpoint   = aws_eks_cluster.main.endpoint
    oidc_issuer       = aws_eks_cluster.main.identity[0].oidc[0].issuer
    prometheus_config = {
      cluster_name = aws_eks_cluster.main.name
      region       = data.aws_region.current.name
    }
  }
}

#==========================================
# GitOps Integration
#==========================================

output "argocd_config" {
  description = "Configuration values for ArgoCD deployment"
  value = {
    cluster = {
      name   = aws_eks_cluster.main.name
      server = aws_eks_cluster.main.endpoint
    }
    destination = {
      namespace = "argocd"
      server    = "https://kubernetes.default.svc"
    }
    source_repo_url = "https://github.com/YOUR_USERNAME/geodish-gitops.git"
  }
}

#==========================================
# Security and Compliance
#==========================================

output "security_summary" {
  description = "Security configuration summary"
  value = {
    private_endpoint_enabled      = var.cluster_endpoint_private_access
    public_endpoint_enabled       = var.cluster_endpoint_public_access
    public_access_cidrs          = var.cluster_endpoint_public_access_cidrs
    nodes_in_private_subnets     = true
    irsa_enabled                 = var.enable_irsa
    logging_enabled              = length(var.cluster_enabled_log_types) > 0
    encryption_at_rest           = "Managed by AWS"
    network_security            = "Private subnets + Security groups"
  }
}

#==========================================
# Environment and Regional Information
#==========================================

data "aws_region" "current" {}

output "cluster_region" {
  description = "AWS region where the cluster is deployed"
  value       = data.aws_region.current.name
}

output "cluster_tags" {
  description = "Tags applied to the EKS cluster"
  value       = local.common_tags
}

#==========================================
# Complete Cluster Summary
#==========================================

output "cluster_summary" {
  description = "Complete summary of EKS cluster configuration"
  value = {
    # Basic Information
    name            = aws_eks_cluster.main.name
    version         = aws_eks_cluster.main.version
    status          = aws_eks_cluster.main.status
    endpoint        = aws_eks_cluster.main.endpoint
    region          = data.aws_region.current.name
    
    # Node Information
    node_group = {
      name           = aws_eks_node_group.main.node_group_name
      instance_types = aws_eks_node_group.main.instance_types
      capacity_type  = aws_eks_node_group.main.capacity_type
      ami_type      = aws_eks_node_group.main.ami_type
      scaling_config = aws_eks_node_group.main.scaling_config[0]
    }
    
    # Security
    private_subnets_only = true
    irsa_enabled        = var.enable_irsa
    
    # Add-ons
    essential_addons = ["vpc-cni", "coredns", "kube-proxy"]
    optional_addons  = var.enable_ebs_csi_driver ? ["aws-ebs-csi-driver"] : []
    
    # Ready for deployment
    ready_for_geodish_app = aws_eks_cluster.main.status == "ACTIVE"
  }
}
